!function(){return function t(e,s,o){function r(i,c){if(!s[i]){if(!e[i]){var a="function"==typeof require&&require;if(!c&&a)return a(i,!0);if(n)return n(i,!0);var u=new Error("Cannot find module '"+i+"'");throw u.code="MODULE_NOT_FOUND",u}var h=s[i]={exports:{}};e[i][0].call(h.exports,function(t){return r(e[i][1][t]||t)},h,h.exports,t,e,s,o)}return s[i].exports}for(var n="function"==typeof require&&require,i=0;i<o.length;i++)r(o[i]);return r}}()({1:[function(t,e,s){const o=t("./lib/eventEmitter"),r=t("./lib/subprotocol/jsonRWS"),n=t("./lib/Router"),i=t("./lib/helper");class c{constructor(t){this.wcOpts=t,this.wsocket,this.socketID,this.attempt=1,this.router=new n({debug:t.debug})}connect(){const t=this.wcOpts.wsURL;return this.wsocket=new WebSocket(t,this.wcOpts.subprotocols),this.onEvents(),new Promise(t=>{o.once("connected",()=>{t(this.wsocket)})})}disconnect(){this.wsocket&&this.wsocket.close(),this.blockReconnect()}async reconnect(){const t=this.wcOpts.reconnectAttempts,e=this.wcOpts.reconnectDelay;this.attempt<=t&&(await i.sleep(e),this.connect(),console.log(`Reconnect attempt #${this.attempt} of ${t} in ${e}ms`),this.attempt++)}blockReconnect(){this.attempt=this.wcOpts.reconnectAttempts+1}onEvents(){this.wsocket.onopen=(async t=>{this.onMessage(),console.log("WS Connection opened"),this.attempt=1,this.socketID=await this.infoSocketId(),console.log(`socketID: ${this.socketID}`),o.emit("connected")}),this.wsocket.onclose=(t=>{console.log("WS Connection closed"),delete this.wsocket,delete this.socketID,this.reconnect()}),this.wsocket.onerror=(t=>{})}onMessage(){this.wsocket.onmessage=(t=>{try{const e=t.data;this.debugger("Received::",e);const s=r.incoming(e),n={msg:s,msgSTR:e};"route"===s.cmd?o.emit("route",n):"info/socket/id"===s.cmd?o.emit("question",n):"info/socket/list"===s.cmd?o.emit("question",n):"info/room/list"===s.cmd?o.emit("question",n):"info/room/listmy"===s.cmd?o.emit("question",n):o.emit("message",n)}catch(t){console.error(t)}})}question(t){const e=this.socketID;return this.carryOut(e,t,void 0),new Promise(async(e,s)=>{this.once("question",async(o,r)=>{o.cmd===t?e(o):s(new Error("Recived cmd is not same as sent cmd."))}),await i.sleep(this.wcOpts.timeout),s(new Error(`No answer for the question: ${t}`))})}async infoSocketId(){const t=await this.question("info/socket/id");return this.socketID=+t.payload,this.socketID}async infoSocketList(){return(await this.question("info/socket/list")).payload}async infoRoomList(){return(await this.question("info/room/list")).payload}async infoRoomListmy(){return(await this.question("info/room/listmy")).payload}carryOut(t,e,s){t||(t=0);const o={id:i.generateID(),from:+this.socketID,to:t,cmd:e,payload:s},n=r.outgoing(o);if(this.debugger("Sent::",n),!n||!this.wsocket||1!==this.wsocket.readyState)throw new Error("The message is not defined or the client is disconnected.");this.wsocket.send(n)}sendOne(t,e){const s=e;this.carryOut(t,"socket/sendone",s)}send(t,e){const s=e;this.carryOut(t,"socket/send",s)}broadcast(t){const e=t;this.carryOut(0,"socket/broadcast",e)}sendAll(t){const e=t;this.carryOut(0,"socket/sendall",e)}roomEnter(t){const e=t;this.carryOut(0,"room/enter",e)}roomExit(t){const e=t;this.carryOut(0,"room/exit",e)}roomExitAll(){this.carryOut(0,"room/exitall",void 0)}roomSend(t,e){const s=t,o=e;this.carryOut(s,"room/send",o)}setNick(t){const e=t;this.carryOut(0,"socket/nick",e)}route(t,e){const s={uri:t,body:e};this.carryOut(0,"route",s)}on(t,e){return o.on(t,t=>{e.call(null,t.detail.msg,t.detail.msgSTR)})}once(t,e){return o.on(t,t=>{e.call(null,t.detail.msg,t.detail.msgSTR)})}off(t){return o.off(t)}debugger(...t){const e=t.join("");this.wcOpts.debug&&console.log(e)}}window.regoch={Client13jsonRWS:c,Router:n,helper:i},e.exports={Client13jsonRWS:c,Router:n,helper:i}},{"./lib/Router":2,"./lib/eventEmitter":3,"./lib/helper":4,"./lib/subprotocol/jsonRWS":5}],2:[function(t,e,s){e.exports=class{constructor(t){this.routerOpts=t||{},this.trx,this.routeDefs=[]}set trx(t){if(!t.uri)throw new Error('The "uri" property is required.');Object.defineProperty(t,"uri",{value:t.uri,writable:!1}),Object.defineProperty(t,"body",{value:t.body,writable:!1}),t.uriParsed=this._uriParser(t.uri),this._trx=t}get trx(){return this._trx}def(t,...e){return this.routeDefs.push({route:t,routeParsed:this._routeParser(t),funcs:e}),this}redirect(t,e){const s=this.routeDefs.find(t=>t.route===e),o=s?s.funcs:[];return this.def(t,...o),this}notfound(...t){return this.def("<notfound>",...t),this}do(...t){return this.def("<do>",...t),this}async exe(){const t=this.trx.uriParsed,e=this.routeDefs.find(e=>{const s=e.routeParsed;return this._routeRegexMatchNoParams(s,t)||this._routeWithParamsMatch(s,t)}),s=this.routeDefs.find(t=>"<notfound>"===t.route),o=this.routeDefs.find(t=>"<do>"===t.route);if(e){this.trx.routeParsed=e.routeParsed,this.trx.query=t.queryObject,this.trx.params=this.trx.routeParsed?this._getParams(e.routeParsed.full,t.path):{};for(const t of e.funcs)await t(this.trx)}else if(s)for(const t of s.funcs)await t(this.trx);if(o&&o.funcs&&o.funcs.length)for(const t of o.funcs)await t(this.trx);return this.trx}_routeRegexMatchNoParams(t,e){const s=new RegExp(`^${t.full}$`,"i").test(e.path),o=t.segments===e.segments,r=s&&o;return this.routerOpts.debug&&console.log(`\n_routeRegexMatchNoParams:: (route) ${t.full} - (uri) ${e.path} -> ${r}`),r}_routeWithParamsMatch(t,e){const s=new RegExp(`^${t.base}/`,"i").test(e.path),o=t.segments===e.segments,r=/\/\:/.test(t.full),n=s&&o&&r;return this.routerOpts.debug&&console.log(`_routeWithParamsMatch:: (route) ${t.full} - (uri) ${e.path} -> ${n}`),n}_removeSlashes(t){return t.trim().replace(/^\/+/,"").replace(/\/+$/,"")}_typeConvertor(t){return t&&!isNaN(t)&&-1===t.indexOf(".")?t=parseInt(t,10):t&&!isNaN(t)&&-1!==t.indexOf(".")?t=parseFloat(t):"true"===t||"false"===t?t=JSON.parse(t):function(t){try{JSON.parse(t)}catch(t){return!1}return!0}(t)&&(t=JSON.parse(t)),t}_toQueryObject(t){const e=t.split("&"),s={};let o,r,n;return e.forEach(t=>{o=t.split("="),r=o[0],n=o[1],n=this._typeConvertor(n),s[r]=n}),s}_uriParser(t){const e=t.split("?"),s=this._removeSlashes(e[0]),o=s.split("/").length,r=e[1];return{path:s,segments:o,queryString:r,queryObject:r?this._toQueryObject(r):{}}}_routeParser(t){const e=this._removeSlashes(t),s=e.split("/").length,o=e.replace(/\/\:.+/,"");return{full:e,segments:s,base:o}}_getParams(t,e){const s=t.split("/"),o=e.split("/"),r={};return s.forEach((t,e)=>{if(/\:/.test(t)){const s=t.replace(/^\:/,"");let n=o[e];n=this._typeConvertor(n),r[s]=n}}),r}}},{}],3:[function(t,e,s){e.exports=new class{emit(t,e){const s=new CustomEvent(t,{detail:e});window.dispatchEvent(s)}on(t,e){window.addEventListener(t,t=>{e(t)})}once(t,e){window.addEventListener(t,s=>{e(s),window.removeEventListener(t,()=>{})},{once:!0})}off(t){window.removeEventListener(t,t=>{})}}},{}],4:[function(t,e,s){const o=new class{getMessageSize(t){return+new Blob([t]).size}async sleep(t){await new Promise(e=>setTimeout(e,t))}generateID(){const t=1e3*Math.random(),e=Math.floor(t);return+((new Date).toISOString().replace(/^20/,"").replace(/\-/g,"").replace(/\:/g,"").replace("T","").replace("Z","").replace(".","")+e)}};e.exports=o},{}],5:[function(t,e,s){e.exports=new class{incoming(t){let e,s=!1;try{e=JSON.parse(t);const o=Object.keys(e);s=this._testFields(o)}catch(t){s=!1}if(s)return e;throw new Error(`Incoming message "${t}" doesn't have valid "jsonRWS" subprotocol format.`)}outgoing(t){const e=Object.keys(t);if(this._testFields(e))return JSON.stringify(t);throw new Error(`Outgoing message ${JSON.stringify(t)} doesn't have valid "jsonRWS" subprotocol format.`)}_testFields(t){const e=["id","from","to","cmd","payload"],s=["id","from","to","cmd"];let o=!0;for(const s of t)if(-1===e.indexOf(s)){o=!1;break}for(const e of s)if(-1===t.indexOf(e)){o=!1;break}return o}}},{}]},{},[1]);
//# sourceMappingURL=client13jsonRWS-min.js.map
