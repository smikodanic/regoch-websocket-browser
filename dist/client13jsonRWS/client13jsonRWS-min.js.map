{"version":3,"sources":["client13jsonRWS.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","jsonRWS","Router","helper","window","regoch","Client13jsonRWS","[object Object]","wcOpts","this","wsocket","socketID","attempt","wsURL","WebSocket","subprotocols","onEvents","router","debug","close","attempts","recconectAttempts","delay","recconectDelay","sleep","connect","console","log","onopen","async","openEvt","infoSocketId","onclose","closeEvt","reconnect","onerror","errorEvt","cb","onmessage","event","msgSTR","data","debugger","msg","incoming","cmd","to","carryOut","undefined","Promise","resolve","reject","onMessage","msgObj","timeout","answer","question","payload","id","generateID","from","outgoing","readyState","send","roomName","nickname","uri","body","textParts","text","join","./lib/Router","./lib/helper","./lib/subprotocol/jsonRWS","2","routerOpts","trx","routeDefs","obj","Object","defineProperty","value","writable","uriParsed","_uriParser","_trx","route","funcs","push","routeParsed","_routeParser","fromRoute","toRoute","toRouteDef","find","routeDef","toFuncs","def","routeDef_found","_routeRegexMatchNoParams","_routeWithParamsMatch","routeDef_notfound","routeDef_do","query","queryObject","params","_getParams","full","path","func","tf1","RegExp","test","tf2","segments","tf","base","tf3","trim","replace","isNaN","indexOf","parseInt","parseFloat","JSON","parse","str","err","isJSON","queryString","queryArr","split","eqParts","property","forEach","elem","_typeConvertor","uriDivided","_removeSlashes","_toQueryObject","routeParsedFull","uriParsedPath","routeParts","uriParts","routePart","index","3","Blob","size","ms","setTimeout","rnd","Math","random","rrr","floor","Date","toISOString","4","msgObjProperties","keys","_testFields","stringify","allowedFields","requiredFields","prop","requiredField"],"mappings":"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","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n * Websocket Client for Browser\n * - websocket version: 13\n * - subprotocol: jsonRWS\n */\nconst jsonRWS = require('./lib/subprotocol/jsonRWS');\nconst Router = require('./lib/Router');\nconst helper = require('./lib/helper');\n\n\nclass Client13jsonRWS {\n\n  /**\n   * @param {{wsURL:string, timeout:number, recconectAttempts:number, reconnectDelay:number, subprotocols:string[], debug:boolean}} wcOpts - websocket client options\n   */\n  constructor(wcOpts) {\n    this.wcOpts = wcOpts; // websocket client options\n    this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n    this.socketID; // socket ID number, for example: 210214082949459100\n    this.attempt = 1; // reconnect attempt counter\n  }\n\n\n  /************* CLIENT CONNECTOR ************/\n  /**\n   * Connect to the websocket server.\n   * @returns {void}\n   */\n  connect() {\n    const wsURL = this.wcOpts.wsURL; // websocket URL: ws://localhost:3211/something?authkey=TRTmrt\n    this.wsocket = new WebSocket(wsURL, this.wcOpts.subprotocols);\n    this.onEvents();\n\n    this.router = new Router(this.wcOpts.debug);\n  }\n\n\n  /**\n   * Disconnect from the websocket server.\n   * @returns {void}\n   */\n  disconnect() {\n    this.wsocket.close();\n  }\n\n\n  /**\n   * Try to reconnect the client when the socket is closed.\n   * This method is fired on every 'close' socket's event.\n   */\n  async reconnect() {\n    const attempts = this.wcOpts.recconectAttempts;\n    const delay = this.wcOpts.recconectDelay;\n    if (this.attempt <= attempts) {\n      await helper.sleep(delay);\n      this.connect();\n      console.log(`Reconnect attempt #${this.attempt} of ${attempts} in ${delay}ms`);\n      this.attempt++;\n    }\n  }\n\n\n\n  /**\n   * Event listeners.\n   * @returns {void}\n   */\n  onEvents() {\n    this.wsocket.onopen = async (openEvt) => {\n      console.log('WS Connection opened');\n      this.attempt = 1;\n      this.socketID = await this.infoSocketId();\n    };\n\n    this.wsocket.onclose = (closeEvt) => {\n      console.log('WS Connection closed');\n      delete this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n      delete this.socketID;\n      this.reconnect();\n    };\n\n    this.wsocket.onerror = (errorEvt) => {\n      // console.error(errorEvt);\n    };\n  }\n\n\n\n\n  /************* RECEIVER ************/\n  /**\n   * Receive the message event and push it to msgStream.\n   * @param {Function} - callback function\n   * @returns {void}\n   */\n  onMessage(cb) {\n    this.wsocket.onmessage = (event) => {\n      const msgSTR = event.data;\n      this.debugger('Received: ', msgSTR);\n      const msg = jsonRWS.incoming(msgSTR); // test against subprotocol rules and convert string to object\n      cb(msg, msgSTR);\n    };\n  }\n\n\n\n  /************* QUESTIONS ************/\n  /*** Send a question to the websocket server and wait for the answer. */\n  /**\n   * Send question and expect the answer.\n   * @param {string} cmd - command\n   * @returns {Promise<object>}\n   */\n  question(cmd) {\n    // send the question\n    const payload = undefined;\n    const to = this.socketID;\n    this.carryOut(to, cmd, payload);\n\n    // receive the answer\n    return new Promise(async (resolve, reject) => {\n      this.onMessage(async (msgObj) => {\n        if (msgObj.cmd === cmd) { resolve(msgObj); }\n      });\n      await helper.sleep(this.wcOpts.timeout);\n      reject(new Error(`No answer for the question: ${cmd}`));\n    });\n  }\n\n  /**\n   * Send question about my socket ID.\n   * @returns {Promise<number>}\n   */\n  async infoSocketId() {\n    const answer = await this.question('info/socket/id');\n    this.socketID = +answer.payload;\n    return this.socketID;\n  }\n\n  /**\n   * Send question about all socket IDs connected to the server.\n   * @returns {Promise<number[]>}\n   */\n  async infoSocketList() {\n    const answer = await this.question('info/socket/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms in the server.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomList() {\n    const answer = await this.question('info/room/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms where the client was entered.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomListmy() {\n    const answer = await this.question(`info/room/listmy`);\n    return answer.payload;\n  }\n\n\n\n\n\n\n  /************* SEND MESSAGE TO OTHER CLIENTS ************/\n  /**\n   * Send message to the websocket server if the connection is not closed (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState).\n   * @param {number} to - final destination: 210201164339351900\n   * @param {string} cmd - command\n   * @param {any} payload - message payload\n   * @returns {void}\n   */\n  carryOut(to, cmd, payload) {\n    const id = helper.generateID(); // the message ID\n    const from = +this.socketID; // the sender ID\n    if (!to) { to = 0; } // server ID is 0\n    const msgObj = {id, from, to, cmd, payload};\n    const msg = jsonRWS.outgoing(msgObj);\n\n    // the message must be defined and client must be connected to the server\n    if (!!msg && !!this.wsocket && this.wsocket.readyState === 1) {\n      this.wsocket.send(msg);\n    } else {\n      throw new Error('The message is not defined or the client is disconnected.');\n    }\n  }\n\n\n  /**\n   * Send message (payload) to one client.\n   * @param {number} to - 210201164339351900\n   * @param {any} msg - message sent to the client\n   * @returns {void}\n   */\n  sendOne(to, msg) {\n    const cmd = 'socket/sendone';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to one or more clients.\n   * @param {number[]} to - [210205081923171300, 210205082042463230]\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  send(to, msg) {\n    const cmd = 'socket/send';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to all clients except the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  broadcast(msg) {\n    const cmd = 'socket/broadcast';\n    const payload = msg;\n    this.carryOut(cmd, payload);\n  }\n\n  /**\n   * Send message (payload) to all clients and the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  sendAll(msg) {\n    const cmd = 'socket/sendall';\n    const payload = msg;\n    this.carryOut(cmd, payload);\n  }\n\n\n\n  /************* ROOM ************/\n  /**\n   * Subscribe in the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  roomEnter(roomName) {\n    const to = 0;\n    const cmd = 'room/enter';\n    const payload = roomName;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  roomExit(roomName) {\n    const to = 0;\n    const cmd = 'room/exit';\n    const payload = roomName;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from all rooms.\n   * @returns {void}\n   */\n  roomExitAll() {\n    const to = 0;\n    const cmd = 'room/exitall';\n    const payload = undefined;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message to the room.\n   * @param {string} roomName\n   * @param {any} msg\n   * @returns {void}\n   */\n  roomSend(roomName, msg) {\n    const to = roomName;\n    const cmd = 'room/send';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /********* SEND MESSAGE (COMMAND) TO SERVER *********/\n  /**\n   * Setup a nick name.\n   * @param {string} nickname - nick name\n   * @returns {void}\n   */\n  setNick(nickname) {\n    const to = 0;\n    const cmd = 'socket/nick';\n    const payload = nickname;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send route command.\n   * @param {string} uri - route URI, for example /shop/product/55\n   * @param {any} body - body\n   * @returns {void}\n   */\n  route(uri, body) {\n    const to = 0;\n    const cmd = 'route';\n    const payload = {uri, body};\n    this.carryOut(to, cmd, payload);\n  }\n\n\n\n  /**\n   * Debugger. Use it as this.debug(var1, var2, var3)\n   * @returns {void}\n   */\n  debugger(...textParts) {\n    const text = textParts.join('');\n    if (this.wcOpts.debug) { console.log(text); }\n  }\n\n\n\n}\n\n\nwindow.regoch = { Client13jsonRWS, Router };\n\n},{\"./lib/Router\":2,\"./lib/helper\":3,\"./lib/subprotocol/jsonRWS\":4}],2:[function(require,module,exports){\n/**\n * Terminology\n * =================================\n * route :string - defined route in the def() method - /room/subscribe/:room_name/:id\n * routeParsed.full :string - full route (start and end slashes removed) - 'room/subscribe/:room_name/:id'\n * routeParsed.segments :number - number the full route segments (with param parts) - 4\n * routeParsed.base :number - route part without params segments (start and end slashes removed) - 'room/subscribe'\n *\n * uri :string - current URI - /room/subscribe/sasa/123?x=123&y=abc&z=false\n * uriParsed.path :string - complete uri (start and end slashes removed) - '/room/subscribe/sasa/123'\n * uriParsed.segments :number - number of the uri segments - 4\n * uriParsed.queryString :string - uri part after question mark as string - 'x=123&y=abc&z=false'\n * uriParsed.queryObject :object - uri part parsed as object - {x: 123, y: 'abc', z: false}\n *\n * body :any - data sent along with uri as the transitional object - trx: {uri, body}\n *\n * func :Function - route function - a function which is executed when certain route is matched against the uri\n * trx :object - transitional object which can be changed in the route functions, required field is \"uri\" - {uri, body, uriParsed, routeParsed, params, query}\n *\n * Notice\n *-----------\n * Variables \"uri\" and \"body\" are analogous to HTTP POST request, for example:  POST /room/subscribe/sasa/123?key=999  {a: 'something})\n */\n\n\n\nclass Router {\n\n  /**\n   * @param {object} routerOpts - router initial options {debug:boolean}\n   */\n  constructor(routerOpts) {\n    this.routerOpts = routerOpts || {};\n    this.trx; // transitional object {uri:string, body:any, ...}\n    this.routeDefs = []; // route definitions [{route:string, routeParsed:object, funcs:Function[] }]\n  }\n\n\n  /**\n   * Set transitional object.\n   * @param {object} obj - {uri, body, ...}\n   * @returns {void}\n   */\n  set trx(obj) {\n    // required properties\n    if (!obj.uri) { throw new Error('The \"uri\" property is required.'); }\n\n    // \"uri\" and \"body\" as properties with constant value (can not be modified)\n    Object.defineProperty(obj, 'uri', {\n      value: obj.uri,\n      writable: false\n    });\n\n    Object.defineProperty(obj, 'body', {\n      value: obj.body,\n      writable: false\n    });\n\n    // parse uri\n    obj.uriParsed = this._uriParser(obj.uri);\n\n    this._trx = obj;\n  }\n\n\n  /**\n   * Get transitional object.\n   * @returns {object} - {uri, body, ...}\n   */\n  get trx() {\n    return this._trx;\n  }\n\n\n\n  /**\n   * Define route, routeParsed and corresponding functions.\n   * @param {string} route - /room/subscribe/:room_name\n   * @param {Function[]} funcs - route functions\n   * @returns {Router}\n   */\n  def(route, ...funcs) {\n    this.routeDefs.push({\n      route,\n      routeParsed: this._routeParser(route),\n      funcs\n    });\n    return this;\n  }\n\n\n  /**\n   * Redirect from one route to another route.\n   * @param {string} fromRoute - new route\n   * @param {string} toRoute - destination route (where to redirect)\n   * @returns {Router}\n   */\n  redirect(fromRoute, toRoute) {\n    const toRouteDef = this.routeDefs.find(routeDef => routeDef.route === toRoute); // {route, routeParsed, funcs}\n    const toFuncs = !!toRouteDef ? toRouteDef.funcs : [];\n    this.def(fromRoute, ...toFuncs); // assign destination functions to the new route\n    return this;\n  }\n\n\n  /**\n   * Define special route <notfound>\n   * @param {Function[]} funcs - function which will be executed when route is not matched aginst URI\n   * @returns {Router}\n   */\n  notfound(...funcs) {\n    this.def('<notfound>', ...funcs);\n    return this;\n  }\n\n\n\n  /**\n   * Define special route <do>\n   * @param {Function[]} funcs - function which will be executed on every request, e.g. every exe()\n   * @returns {Router}\n   */\n  do(...funcs) {\n    this.def('<do>', ...funcs);\n    return this;\n  }\n\n\n\n\n  /**\n   * Execute the router functions.\n   * @returns {Promise<object>}\n   */\n  async exe() {\n    const uriParsed = this.trx.uriParsed; // shop/register/john/23\n\n    /*** FIND ROUTE ***/\n    // found route definition\n    const routeDef_found = this.routeDefs.find(routeDef => { // {route, routeParsed, funcs}\n      const routeParsed = routeDef.routeParsed; // {full, segments, base}\n      return this._routeRegexMatchNoParams(routeParsed, uriParsed) || this._routeWithParamsMatch(routeParsed, uriParsed);\n    });\n\n    // not found route definition\n    const routeDef_notfound = this.routeDefs.find(routeDef => routeDef.route === '<notfound>');\n\n    // do route definition\n    const routeDef_do = this.routeDefs.find(routeDef => routeDef.route === '<do>');\n\n    /*** EXECUTE FOUND ROUTE FUNCTIONS */\n    if (!!routeDef_found) {\n      this.trx.routeParsed = routeDef_found.routeParsed;\n      this.trx.query = uriParsed.queryObject;\n      this.trx.params = !!this.trx.routeParsed ? this._getParams(routeDef_found.routeParsed.full, uriParsed.path) : {};\n\n      for (const func of routeDef_found.funcs) { await func(this.trx); }\n    } else if (!!routeDef_notfound) {\n      for (const func of routeDef_notfound.funcs) { await func(this.trx); }\n    }\n\n\n    if (!!routeDef_do && !!routeDef_do.funcs && !!routeDef_do.funcs.length) {\n      for (const func of routeDef_do.funcs) { await func(this.trx); }\n    }\n\n\n    return this.trx;\n  }\n\n\n\n\n\n  /*********** ROUTE MATCHES  ***********/\n\n  /**\n   * Route regular expression match against the uri. Parameters are not defined in the route e.g. there is no /: chars.\n   * For example:\n   *       (route) /ads/autos/bmw - (uri) /ads/autos/bmw -> true\n   *       (route) /ads/a.+s/bmw  - (uri) /ads/autos/bmw -> true\n   * @param {object} routeParsed - {full, segments, base}\n   * @param {object} uriParsed - {path, segments, queryString, queryObject}\n   * @returns {boolean}\n   */\n  _routeRegexMatchNoParams(routeParsed, uriParsed) {\n    const routeReg = new RegExp(`^${routeParsed.full}$`, 'i');\n    const tf1 = routeReg.test(uriParsed.path); // route must match uri\n    const tf2 = routeParsed.segments === uriParsed.segments; // route and uri must have same number of segments\n    const tf = tf1 && tf2;\n    if (this.routerOpts.debug) { console.log(`\\n_routeRegexMatchNoParams:: (route) ${routeParsed.full} - (uri) ${uriParsed.path} -> ${tf}`); }\n    return tf;\n  }\n\n\n  /**\n   * Route with parameters match against the uri.\n   * (route) /shop/register/:name/:age - (uri) /shop/register/john/23\n   * @param {object} routeParsed - {full, segments, base}\n   * @param {object} uriParsed - {path, segments, queryString, queryObject}\n   * @returns {boolean}\n   */\n  _routeWithParamsMatch(routeParsed, uriParsed) {\n    const routeReg = new RegExp(`^${routeParsed.base}\\/`, 'i');\n    const tf1 = routeReg.test(uriParsed.path); // route base must match uri\n    const tf2 = routeParsed.segments === uriParsed.segments; // route and uri must have same number of segments\n    const tf3 = /\\/\\:/.test(routeParsed.full); // route must have at least one /:\n    const tf = tf1 && tf2 && tf3;\n    if (this.routerOpts.debug) { console.log(`_routeWithParamsMatch:: (route) ${routeParsed.full} - (uri) ${uriParsed.path} -> ${tf}`); }\n    return tf;\n  }\n\n\n\n\n  /*********** HELPERS  ***********/\n\n  /**\n   * Removing slashes from the beginning and the end.\n   * /ads/autos/bmw/ --> ads/autos/bmw\n   * //ads/autos/bmw/// --> ads/autos/bmw\n   * @param {string} path - uri path or route\n   * @returns {string}\n   */\n  _removeSlashes(path) {\n    return path.trim().replace(/^\\/+/, '').replace(/\\/+$/, '');\n  }\n\n\n  /**\n   * Convert string into integer, float or boolean.\n   * @param {string} value\n   * @returns {string | number | boolean | object}\n   */\n  _typeConvertor(value) {\n    function isJSON(str) {\n      try { JSON.parse(str); }\n      catch(err) { return false; }\n      return true;\n    }\n\n    if (!!value && !isNaN(value) && value.indexOf('.') === -1) { // convert string into integer (12)\n      value = parseInt(value, 10);\n    } else if (!!value && !isNaN(value) && value.indexOf('.') !== -1) { // convert string into float (12.35)\n      value = parseFloat(value);\n    } else if (value === 'true' || value === 'false') { // convert string into boolean (true)\n      value = JSON.parse(value);\n    } else if (isJSON(value)) {\n      value = JSON.parse(value);\n    }\n\n    return value;\n  }\n\n\n\n  /**\n   * Create query object from query string.\n   * @param  {string} queryString - x=abc&y=123&z=true\n   * @return {object}             - {x: 'abc', y: 123, z: true}\n   */\n  _toQueryObject(queryString) {\n    const queryArr = queryString.split('&');\n    const queryObject = {};\n\n    let eqParts, property, value;\n    queryArr.forEach(elem => {\n      eqParts = elem.split('='); // equotion parts\n      property = eqParts[0];\n      value = eqParts[1];\n\n      value = this._typeConvertor(value); // t y p e   c o n v e r s i o n\n\n      queryObject[property] = value;\n    });\n\n    return queryObject;\n  }\n\n\n\n  /**\n   * URI parser\n   * @param  {string} uri - /shop/register/john/23?x=abc&y=123&z=true  (uri === trx.uri)\n   * @returns {path:string, queryString:string, queryObject:object} - {path: 'shop/register/john/23', queryString: 'x=abc&y=123&z=true', queryObject: {x: 'abc', y: 123, z: true}}\n   */\n  _uriParser(uri) {\n    const uriDivided = uri.split('?');\n\n    const path = this._removeSlashes(uriDivided[0]); // /shop/register/john/23 -> shop/register/john/23\n    const segments = path.split('/').length;\n    const queryString = uriDivided[1];\n    const queryObject = !!queryString ? this._toQueryObject(queryString) : {};\n\n    const uriParsed = {path, segments, queryString, queryObject};\n    return uriParsed;\n  }\n\n\n  /**\n   * Route parser.\n   * Converts route string into the parsed object {full, segments, parser} which is used for matching against the URI.\n   * @param  {string} route - /shop/register/:name/:age/\n   * @returns {full:string, segments:number, base:string} - {full: 'shop/register/:name/:age', segments: 4, base: 'shop/register'}\n   */\n  _routeParser(route) {\n    const full = this._removeSlashes(route);\n    const segments = full.split('/').length;\n    const base = full.replace(/\\/\\:.+/, ''); // shop/register/:name/:age --> shop/register\n\n    const routeParsed = {full, segments, base};\n    return routeParsed;\n  }\n\n\n\n  /**\n   * Create parameters object.\n   * For example if route is /register/:name/:age AND uri is /register/john/23 then params is {name: 'john', age: 23}\n   * @param  {string} routeParsedFull - routeParsed.full -- shop/register/:name/:age\n   * @param  {string} uriParsedPath  - uriParsed.path -- shop/register/john/23\n   * @returns {object}\n   */\n  _getParams(routeParsedFull, uriParsedPath) {\n    const routeParts = routeParsedFull.split('/'); // ['shop', 'register', ':name', ':age']\n    const uriParts = uriParsedPath.split('/'); // ['shop', 'register', 'john', 23]\n\n    const params = {};\n\n    routeParts.forEach((routePart, index) => {\n      if (/\\:/.test(routePart)) {\n        const property = routePart.replace(/^\\:/, ''); // remove :\n\n        let value = uriParts[index];\n        value = this._typeConvertor(value); // t y p e   c o n v e r s i o n\n\n        params[property] = value;\n      }\n    });\n\n    return params;\n  }\n\n\n\n\n\n}\n\n\n\n\n\nmodule.exports = Router;\n\n},{}],3:[function(require,module,exports){\nclass Helper {\n\n  /**\n   * Get message size in bytes.\n   * For example: A -> 1 , Š -> 2 , ABC -> 3\n   * @param {string} msg - message sent to server\n   * @returns {number}\n   */\n  getMessageSize(msg) {\n    const bytes = new Blob([msg]).size;\n    return +bytes;\n  }\n\n\n  /**\n   * Pause the code execution\n   * @param {number} ms - miliseconds\n   * @returns {void}\n   */\n  async sleep(ms) {\n    await new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n\n  /**\n   * Create unique id. It's combination of wsOpts and random number 'r'\n   * in format: YYMMDDHHmmssSSSrrr ---> YY year, MM month, DD day, HH hour, mm min, ss sec, SSS ms, rrr 3 random digits\n   * 18 digits in total, for example: 210129163129492100\n   * @returns {number}\n   */\n  generateID() {\n    const rnd = Math.random() * 1000;\n    const rrr = Math.floor(rnd);\n\n    const timestamp = new Date();\n    const tsp = timestamp.toISOString()\n      .replace(/^20/, '')\n      .replace(/\\-/g, '')\n      .replace(/\\:/g, '')\n      .replace('T', '')\n      .replace('Z', '')\n      .replace('.', '');\n\n    const id = +(tsp + rrr);\n    return id;\n  }\n\n\n\n}\n\nconst helper = new Helper();\nmodule.exports = helper;\n\n},{}],4:[function(require,module,exports){\n/**\n * Subprotocol name: jsonRWS\n * HTTP header: \"Sec-WebSocket-Protocol\": \"jsonRWS\"\n *\n * Subprotocol description:\n *  This subprotocol is created for communication between websocket server and client.\n *\n * Subprotocol definitons:\n *  a) Client have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  b) Server have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  c) The message is converted from string to object.\n */\n\n\nclass JsonRWS {\n\n  /*********** INCOMING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for incoming messages. Filter and map incoming messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}.\n   * 2. Convert the message from string to object.\n   * @param {string} msgSTR -incoming message\n   * @returns {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}}\n   */\n  incoming(msgSTR) {\n    let tf = false;\n    let msg;\n    try {\n      msg = JSON.parse(msgSTR);\n      const msgObjProperties = Object.keys(msg);\n      tf = this._testFields(msgObjProperties);\n    } catch (err) {\n      tf = false;\n    }\n\n    if (tf) { return msg; }\n    else { throw new Error(`Incoming message \"${msgSTR}\" doesn\\'t have valid \"jsonRWS\" subprotocol format.`); }\n  }\n\n\n\n  /*********** OUTGOING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for outgoing messages. Filter and map outgoing messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload:any}.\n   * 2. Convert the message from object to string.\n   * @param {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}} msg - outgoing message\n   * @returns {string}\n   */\n  outgoing(msg) {\n    const msgObjProperties = Object.keys(msg);\n    const tf = this._testFields(msgObjProperties);\n\n    if (tf) {\n      const msgSTR = JSON.stringify(msg);\n      return msgSTR;\n    } else {\n      throw new Error(`Outgoing message ${JSON.stringify(msg)} doesn\\'t have valid \"jsonRWS\" subprotocol format.`);\n    }\n  }\n\n\n  /**\n   * Helper to test msg properties.\n   * @param {string[]} msgObjProperties - propewrties of the \"msg\" object\n   */\n  _testFields(msgObjProperties) {\n    const allowedFields = ['id', 'from', 'to', 'cmd', 'payload'];\n    const requiredFields = ['id', 'from', 'to', 'cmd'];\n    let tf = true;\n\n    // check if every of the msg properties are in allowed fields\n    for (const prop of msgObjProperties) {\n      if (allowedFields.indexOf(prop) === -1) { tf = false; break; }\n    }\n\n    // check if every of required fields is present\n    for (const requiredField of requiredFields) {\n      if(msgObjProperties.indexOf(requiredField) === -1) { tf = false; break; }\n    }\n\n    return tf;\n  }\n\n\n\n\n}\n\n\nmodule.exports = new JsonRWS();\n\n},{}]},{},[1]);\n"],"file":"client13jsonRWS-min.js"}