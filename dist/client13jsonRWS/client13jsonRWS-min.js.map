{"version":3,"sources":["client13jsonRWS.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","once","emitter","name","Promise","resolve","reject","eventListener","undefined","errorListener","removeListener","slice","arguments","err","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","warned","w","String","count","console","warn","_onceWrap","state","fired","wrapFn","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","copy","defineProperty","enumerable","get","set","arg","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","handler","len","listeners","addListener","on","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","2","jsonRWS","Router","helper","window","regoch","Client13jsonRWS","[object Object]","wcOpts","wsocket","socketID","attempt","eventEmitter","router","debug","wsURL","WebSocket","subprotocols","onEvents","close","attempts","reconnectAttempts","delay","reconnectDelay","sleep","connect","log","onopen","async","openEvt","infoSocketId","onMessage","onclose","closeEvt","reconnect","onerror","errorEvt","cb","toEmit","onmessage","event","msgSTR","data","debugger","msg","incoming","cmd","to","carryOut","msgObj","timeout","answer","question","payload","id","generateID","from","outgoing","readyState","send","roomName","nickname","uri","body","eventName","textParts","text","join","./lib/Router","./lib/helper","./lib/subprotocol/jsonRWS","3","routerOpts","trx","routeDefs","obj","writable","uriParsed","_uriParser","_trx","route","funcs","routeParsed","_routeParser","fromRoute","toRoute","toRouteDef","find","routeDef","toFuncs","def","routeDef_found","_routeRegexMatchNoParams","_routeWithParamsMatch","routeDef_notfound","routeDef_do","query","queryObject","params","_getParams","full","path","func","tf1","RegExp","test","tf2","segments","tf","base","tf3","trim","replace","indexOf","parseInt","parseFloat","JSON","parse","str","isJSON","queryString","queryArr","split","eqParts","property","forEach","elem","_typeConvertor","uriDivided","_removeSlashes","_toQueryObject","routeParsedFull","uriParsedPath","routeParts","uriParts","routePart","4","Blob","size","ms","setTimeout","rnd","Math","random","rrr","floor","Date","toISOString","5","msgObjProperties","_testFields","stringify","allowedFields","requiredFields","prop","requiredField"],"mappings":"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","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n\n},{}],2:[function(require,module,exports){\n/**\n * Websocket Client for Browser\n * - websocket version: 13\n * - subprotocol: jsonRWS\n */\nconst { EventEmitter } = require('events');\nconst jsonRWS = require('./lib/subprotocol/jsonRWS');\nconst Router = require('./lib/Router');\nconst helper = require('./lib/helper');\n\n\nclass Client13jsonRWS {\n\n  /**\n   * @param {{wsURL:string, timeout:number, reconnectAttempts:number, reconnectDelay:number, subprotocols:string[], debug:boolean}} wcOpts - websocket client options\n   */\n  constructor(wcOpts) {\n    this.wcOpts = wcOpts; // websocket client options\n    this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n    this.socketID; // socket ID number, for example: 210214082949459100\n    this.attempt = 1; // reconnect attempt counter\n    this.eventEmitter = new EventEmitter();\n    this.eventEmitter.setMaxListeners(8);\n\n    this.router = new Router(this.wcOpts.debug);\n  }\n\n\n  /************* CLIENT CONNECTOR ************/\n  /**\n   * Connect to the websocket server.\n   * @returns {Promise<Socket>}\n   */\n  connect() {\n    const wsURL = this.wcOpts.wsURL; // websocket URL: ws://localhost:3211/something?authkey=TRTmrt\n    this.wsocket = new WebSocket(wsURL, this.wcOpts.subprotocols);\n\n    this.onEvents();\n\n    // return socket as promise\n    return new Promise(resolve => {\n      // this.eventEmitter.removeAllListeners(); // not needed if once() is used\n      this.eventEmitter.once('connected', () => { resolve(this.wsocket); });\n      // console.log(`\"connected\" listeners: ${this.eventEmitter.listenerCount('connected')}`.cliBoja('yellow'));\n    });\n  }\n\n\n  /**\n   * Disconnect from the websocket server.\n   * @returns {void}\n   */\n  disconnect() {\n    this.wsocket.close();\n  }\n\n\n  /**\n   * Try to reconnect the client when the socket is closed.\n   * This method is fired on every 'close' socket's event.\n   */\n  async reconnect() {\n    const attempts = this.wcOpts.reconnectAttempts;\n    const delay = this.wcOpts.reconnectDelay;\n    if (this.attempt <= attempts) {\n      await helper.sleep(delay);\n      this.connect();\n      console.log(`Reconnect attempt #${this.attempt} of ${attempts} in ${delay}ms`);\n      this.attempt++;\n    }\n  }\n\n\n\n  /**\n   * Event listeners.\n   * @returns {void}\n   */\n  onEvents() {\n    this.wsocket.onopen = async (openEvt) => {\n      console.log('WS Connection opened');\n      this.attempt = 1;\n      this.socketID = await this.infoSocketId();\n      console.log(`socketID: ${this.socketID}`);\n      this.eventEmitter.emit('connected');\n      this.onMessage(false, true); // emits the messages to eventEmitter\n    };\n\n    this.wsocket.onclose = (closeEvt) => {\n      console.log('WS Connection closed');\n      delete this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n      delete this.socketID;\n      this.reconnect();\n    };\n\n    this.wsocket.onerror = (errorEvt) => {\n      // console.error(errorEvt);\n    };\n  }\n\n\n\n  /************* RECEIVER ************/\n  /**\n   * Receive the message event and push it to msgStream.\n   * @param {Function} cb - callback function\n   * @param {boolean} toEmit - to emit the message into the eventEmitter\n   * @returns {void}\n   */\n  onMessage(cb, toEmit) {\n    this.wsocket.onmessage = (event) => {\n      try {\n        const msgSTR = event.data;\n        this.debugger('Received::', msgSTR);\n        const msg = jsonRWS.incoming(msgSTR); // test against subprotocol rules and convert string to object\n\n        if(!!cb) { cb(msg, msgSTR); }\n\n        if (!!toEmit) {\n          if (msg.cmd === 'route') { this.eventEmitter.emit('route', msg, msgSTR); }\n          else { this.eventEmitter.emit('message', msg, msgSTR); }\n        }\n\n      } catch (err) {\n        console.error(err);\n      }\n\n    };\n  }\n\n\n\n  /************* QUESTIONS ************/\n  /*** Send a question to the websocket server and wait for the answer. */\n  /**\n   * Send question and expect the answer.\n   * @param {string} cmd - command\n   * @returns {Promise<object>}\n   */\n  question(cmd) {\n    // send the question\n    const payload = undefined;\n    const to = this.socketID;\n    this.carryOut(to, cmd, payload);\n\n    // receive the answer\n    return new Promise(async (resolve, reject) => {\n      this.onMessage(async (msgObj) => {\n        if (msgObj.cmd === cmd) { resolve(msgObj); }\n      }, false);\n      await helper.sleep(this.wcOpts.timeout);\n      reject(new Error(`No answer for the question: ${cmd}`));\n    });\n  }\n\n  /**\n   * Send question about my socket ID.\n   * @returns {Promise<number>}\n   */\n  async infoSocketId() {\n    const answer = await this.question('info/socket/id');\n    this.socketID = +answer.payload;\n    return this.socketID;\n  }\n\n  /**\n   * Send question about all socket IDs connected to the server.\n   * @returns {Promise<number[]>}\n   */\n  async infoSocketList() {\n    const answer = await this.question('info/socket/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms in the server.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomList() {\n    const answer = await this.question('info/room/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms where the client was entered.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomListmy() {\n    const answer = await this.question(`info/room/listmy`);\n    return answer.payload;\n  }\n\n\n\n\n\n\n  /************* SEND MESSAGE TO OTHER CLIENTS ************/\n  /**\n   * Send message to the websocket server if the connection is not closed (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState).\n   * @param {number} to - final destination: 210201164339351900\n   * @param {string} cmd - command\n   * @param {any} payload - message payload\n   * @returns {void}\n   */\n  carryOut(to, cmd, payload) {\n    const id = helper.generateID(); // the message ID\n    const from = +this.socketID; // the sender ID\n    if (!to) { to = 0; } // server ID is 0\n    const msgObj = {id, from, to, cmd, payload};\n    const msg = jsonRWS.outgoing(msgObj);\n    this.debugger('Sent::', msg);\n\n    // the message must be defined and client must be connected to the server\n    if (!!msg && !!this.wsocket && this.wsocket.readyState === 1) {\n      this.wsocket.send(msg);\n    } else {\n      throw new Error('The message is not defined or the client is disconnected.');\n    }\n  }\n\n\n  /**\n   * Send message (payload) to one client.\n   * @param {number} to - 210201164339351900\n   * @param {any} msg - message sent to the client\n   * @returns {void}\n   */\n  sendOne(to, msg) {\n    const cmd = 'socket/sendone';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to one or more clients.\n   * @param {number[]} to - [210205081923171300, 210205082042463230]\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  send(to, msg) {\n    const cmd = 'socket/send';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to all clients except the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  broadcast(msg) {\n    const to = 0;\n    const cmd = 'socket/broadcast';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message (payload) to all clients and the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  sendAll(msg) {\n    const to = 0;\n    const cmd = 'socket/sendall';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n\n  /************* ROOM ************/\n  /**\n   * Subscribe in the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  roomEnter(roomName) {\n    const to = 0;\n    const cmd = 'room/enter';\n    const payload = roomName;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  roomExit(roomName) {\n    const to = 0;\n    const cmd = 'room/exit';\n    const payload = roomName;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from all rooms.\n   * @returns {void}\n   */\n  roomExitAll() {\n    const to = 0;\n    const cmd = 'room/exitall';\n    const payload = undefined;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message to the room.\n   * @param {string} roomName\n   * @param {any} msg\n   * @returns {void}\n   */\n  roomSend(roomName, msg) {\n    const to = roomName;\n    const cmd = 'room/send';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /********* SEND MESSAGE (COMMAND) TO SERVER *********/\n  /**\n   * Setup a nick name.\n   * @param {string} nickname - nick name\n   * @returns {void}\n   */\n  setNick(nickname) {\n    const to = 0;\n    const cmd = 'socket/nick';\n    const payload = nickname;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send route command.\n   * @param {string} uri - route URI, for example /shop/product/55\n   * @param {any} body - body\n   * @returns {void}\n   */\n  route(uri, body) {\n    const to = 0;\n    const cmd = 'route';\n    const payload = {uri, body};\n    this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /*********** LISTENERS ************/\n  /**\n   * Wrapper around the eventEmitter\n   * @param {string} eventName - event name: 'connected', 'message', 'route'\n   * @param {Function} listener - callback function\n   */\n  on(eventName, listener) {\n    return this.eventEmitter.on(eventName, listener);\n  }\n\n  /**\n   * Wrapper around the eventEmitter\n   * @param {string} eventName - event name: 'connected', 'message', 'route'\n   * @param {Function} listener - callback function\n   */\n  once(eventName, listener) {\n    return this.eventEmitter.once(eventName, listener);\n  }\n\n\n\n  /*********** MISC ************/\n  /**\n   * Debugger. Use it as this.debug(var1, var2, var3)\n   * @returns {void}\n   */\n  debugger(...textParts) {\n    const text = textParts.join('');\n    if (this.wcOpts.debug) { console.log(text); }\n  }\n\n\n\n\n}\n\n\nwindow.regoch = { Client13jsonRWS, Router };\n\n},{\"./lib/Router\":3,\"./lib/helper\":4,\"./lib/subprotocol/jsonRWS\":5,\"events\":1}],3:[function(require,module,exports){\n/**\n * Terminology\n * =================================\n * route :string - defined route in the def() method - /room/subscribe/:room_name/:id\n * routeParsed.full :string - full route (start and end slashes removed) - 'room/subscribe/:room_name/:id'\n * routeParsed.segments :number - number the full route segments (with param parts) - 4\n * routeParsed.base :number - route part without params segments (start and end slashes removed) - 'room/subscribe'\n *\n * uri :string - current URI - /room/subscribe/sasa/123?x=123&y=abc&z=false\n * uriParsed.path :string - complete uri (start and end slashes removed) - '/room/subscribe/sasa/123'\n * uriParsed.segments :number - number of the uri segments - 4\n * uriParsed.queryString :string - uri part after question mark as string - 'x=123&y=abc&z=false'\n * uriParsed.queryObject :object - uri part parsed as object - {x: 123, y: 'abc', z: false}\n *\n * body :any - data sent along with uri as the transitional object - trx: {uri, body}\n *\n * func :Function - route function - a function which is executed when certain route is matched against the uri\n * trx :object - transitional object which can be changed in the route functions, required field is \"uri\" - {uri, body, uriParsed, routeParsed, params, query}\n *\n * Notice\n *-----------\n * Variables \"uri\" and \"body\" are analogous to HTTP POST request, for example:  POST /room/subscribe/sasa/123?key=999  {a: 'something})\n */\n\n\n\nclass Router {\n\n  /**\n   * @param {object} routerOpts - router initial options {debug:boolean}\n   */\n  constructor(routerOpts) {\n    this.routerOpts = routerOpts || {};\n    this.trx; // transitional object {uri:string, body:any, ...}\n    this.routeDefs = []; // route definitions [{route:string, routeParsed:object, funcs:Function[] }]\n  }\n\n\n  /**\n   * Set transitional object.\n   * @param {object} obj - {uri, body, ...}\n   * @returns {void}\n   */\n  set trx(obj) {\n    // required properties\n    if (!obj.uri) { throw new Error('The \"uri\" property is required.'); }\n\n    // \"uri\" and \"body\" as properties with constant value (can not be modified)\n    Object.defineProperty(obj, 'uri', {\n      value: obj.uri,\n      writable: false\n    });\n\n    Object.defineProperty(obj, 'body', {\n      value: obj.body,\n      writable: false\n    });\n\n    // parse uri\n    obj.uriParsed = this._uriParser(obj.uri);\n\n    this._trx = obj;\n  }\n\n\n  /**\n   * Get transitional object.\n   * @returns {object} - {uri, body, ...}\n   */\n  get trx() {\n    return this._trx;\n  }\n\n\n\n  /**\n   * Define route, routeParsed and corresponding functions.\n   * @param {string} route - /room/subscribe/:room_name\n   * @param {Function[]} funcs - route functions\n   * @returns {Router}\n   */\n  def(route, ...funcs) {\n    this.routeDefs.push({\n      route,\n      routeParsed: this._routeParser(route),\n      funcs\n    });\n    return this;\n  }\n\n\n  /**\n   * Redirect from one route to another route.\n   * @param {string} fromRoute - new route\n   * @param {string} toRoute - destination route (where to redirect)\n   * @returns {Router}\n   */\n  redirect(fromRoute, toRoute) {\n    const toRouteDef = this.routeDefs.find(routeDef => routeDef.route === toRoute); // {route, routeParsed, funcs}\n    const toFuncs = !!toRouteDef ? toRouteDef.funcs : [];\n    this.def(fromRoute, ...toFuncs); // assign destination functions to the new route\n    return this;\n  }\n\n\n  /**\n   * Define special route <notfound>\n   * @param {Function[]} funcs - function which will be executed when route is not matched aginst URI\n   * @returns {Router}\n   */\n  notfound(...funcs) {\n    this.def('<notfound>', ...funcs);\n    return this;\n  }\n\n\n\n  /**\n   * Define special route <do>\n   * @param {Function[]} funcs - function which will be executed on every request, e.g. every exe()\n   * @returns {Router}\n   */\n  do(...funcs) {\n    this.def('<do>', ...funcs);\n    return this;\n  }\n\n\n\n\n  /**\n   * Execute the router functions.\n   * @returns {Promise<object>}\n   */\n  async exe() {\n    const uriParsed = this.trx.uriParsed; // shop/register/john/23\n\n    /*** FIND ROUTE ***/\n    // found route definition\n    const routeDef_found = this.routeDefs.find(routeDef => { // {route, routeParsed, funcs}\n      const routeParsed = routeDef.routeParsed; // {full, segments, base}\n      return this._routeRegexMatchNoParams(routeParsed, uriParsed) || this._routeWithParamsMatch(routeParsed, uriParsed);\n    });\n\n    // not found route definition\n    const routeDef_notfound = this.routeDefs.find(routeDef => routeDef.route === '<notfound>');\n\n    // do route definition\n    const routeDef_do = this.routeDefs.find(routeDef => routeDef.route === '<do>');\n\n    /*** EXECUTE FOUND ROUTE FUNCTIONS */\n    if (!!routeDef_found) {\n      this.trx.routeParsed = routeDef_found.routeParsed;\n      this.trx.query = uriParsed.queryObject;\n      this.trx.params = !!this.trx.routeParsed ? this._getParams(routeDef_found.routeParsed.full, uriParsed.path) : {};\n\n      for (const func of routeDef_found.funcs) { await func(this.trx); }\n    } else if (!!routeDef_notfound) {\n      for (const func of routeDef_notfound.funcs) { await func(this.trx); }\n    }\n\n\n    if (!!routeDef_do && !!routeDef_do.funcs && !!routeDef_do.funcs.length) {\n      for (const func of routeDef_do.funcs) { await func(this.trx); }\n    }\n\n\n    return this.trx;\n  }\n\n\n\n\n\n  /*********** ROUTE MATCHES  ***********/\n\n  /**\n   * Route regular expression match against the uri. Parameters are not defined in the route e.g. there is no /: chars.\n   * For example:\n   *       (route) /ads/autos/bmw - (uri) /ads/autos/bmw -> true\n   *       (route) /ads/a.+s/bmw  - (uri) /ads/autos/bmw -> true\n   * @param {object} routeParsed - {full, segments, base}\n   * @param {object} uriParsed - {path, segments, queryString, queryObject}\n   * @returns {boolean}\n   */\n  _routeRegexMatchNoParams(routeParsed, uriParsed) {\n    const routeReg = new RegExp(`^${routeParsed.full}$`, 'i');\n    const tf1 = routeReg.test(uriParsed.path); // route must match uri\n    const tf2 = routeParsed.segments === uriParsed.segments; // route and uri must have same number of segments\n    const tf = tf1 && tf2;\n    if (this.routerOpts.debug) { console.log(`\\n_routeRegexMatchNoParams:: (route) ${routeParsed.full} - (uri) ${uriParsed.path} -> ${tf}`); }\n    return tf;\n  }\n\n\n  /**\n   * Route with parameters match against the uri.\n   * (route) /shop/register/:name/:age - (uri) /shop/register/john/23\n   * @param {object} routeParsed - {full, segments, base}\n   * @param {object} uriParsed - {path, segments, queryString, queryObject}\n   * @returns {boolean}\n   */\n  _routeWithParamsMatch(routeParsed, uriParsed) {\n    const routeReg = new RegExp(`^${routeParsed.base}\\/`, 'i');\n    const tf1 = routeReg.test(uriParsed.path); // route base must match uri\n    const tf2 = routeParsed.segments === uriParsed.segments; // route and uri must have same number of segments\n    const tf3 = /\\/\\:/.test(routeParsed.full); // route must have at least one /:\n    const tf = tf1 && tf2 && tf3;\n    if (this.routerOpts.debug) { console.log(`_routeWithParamsMatch:: (route) ${routeParsed.full} - (uri) ${uriParsed.path} -> ${tf}`); }\n    return tf;\n  }\n\n\n\n\n  /*********** HELPERS  ***********/\n\n  /**\n   * Removing slashes from the beginning and the end.\n   * /ads/autos/bmw/ --> ads/autos/bmw\n   * //ads/autos/bmw/// --> ads/autos/bmw\n   * @param {string} path - uri path or route\n   * @returns {string}\n   */\n  _removeSlashes(path) {\n    return path.trim().replace(/^\\/+/, '').replace(/\\/+$/, '');\n  }\n\n\n  /**\n   * Convert string into integer, float or boolean.\n   * @param {string} value\n   * @returns {string | number | boolean | object}\n   */\n  _typeConvertor(value) {\n    function isJSON(str) {\n      try { JSON.parse(str); }\n      catch(err) { return false; }\n      return true;\n    }\n\n    if (!!value && !isNaN(value) && value.indexOf('.') === -1) { // convert string into integer (12)\n      value = parseInt(value, 10);\n    } else if (!!value && !isNaN(value) && value.indexOf('.') !== -1) { // convert string into float (12.35)\n      value = parseFloat(value);\n    } else if (value === 'true' || value === 'false') { // convert string into boolean (true)\n      value = JSON.parse(value);\n    } else if (isJSON(value)) {\n      value = JSON.parse(value);\n    }\n\n    return value;\n  }\n\n\n\n  /**\n   * Create query object from query string.\n   * @param  {string} queryString - x=abc&y=123&z=true\n   * @return {object}             - {x: 'abc', y: 123, z: true}\n   */\n  _toQueryObject(queryString) {\n    const queryArr = queryString.split('&');\n    const queryObject = {};\n\n    let eqParts, property, value;\n    queryArr.forEach(elem => {\n      eqParts = elem.split('='); // equotion parts\n      property = eqParts[0];\n      value = eqParts[1];\n\n      value = this._typeConvertor(value); // t y p e   c o n v e r s i o n\n\n      queryObject[property] = value;\n    });\n\n    return queryObject;\n  }\n\n\n\n  /**\n   * URI parser\n   * @param  {string} uri - /shop/register/john/23?x=abc&y=123&z=true  (uri === trx.uri)\n   * @returns {path:string, queryString:string, queryObject:object} - {path: 'shop/register/john/23', queryString: 'x=abc&y=123&z=true', queryObject: {x: 'abc', y: 123, z: true}}\n   */\n  _uriParser(uri) {\n    const uriDivided = uri.split('?');\n\n    const path = this._removeSlashes(uriDivided[0]); // /shop/register/john/23 -> shop/register/john/23\n    const segments = path.split('/').length;\n    const queryString = uriDivided[1];\n    const queryObject = !!queryString ? this._toQueryObject(queryString) : {};\n\n    const uriParsed = {path, segments, queryString, queryObject};\n    return uriParsed;\n  }\n\n\n  /**\n   * Route parser.\n   * Converts route string into the parsed object {full, segments, parser} which is used for matching against the URI.\n   * @param  {string} route - /shop/register/:name/:age/\n   * @returns {full:string, segments:number, base:string} - {full: 'shop/register/:name/:age', segments: 4, base: 'shop/register'}\n   */\n  _routeParser(route) {\n    const full = this._removeSlashes(route);\n    const segments = full.split('/').length;\n    const base = full.replace(/\\/\\:.+/, ''); // shop/register/:name/:age --> shop/register\n\n    const routeParsed = {full, segments, base};\n    return routeParsed;\n  }\n\n\n\n  /**\n   * Create parameters object.\n   * For example if route is /register/:name/:age AND uri is /register/john/23 then params is {name: 'john', age: 23}\n   * @param  {string} routeParsedFull - routeParsed.full -- shop/register/:name/:age\n   * @param  {string} uriParsedPath  - uriParsed.path -- shop/register/john/23\n   * @returns {object}\n   */\n  _getParams(routeParsedFull, uriParsedPath) {\n    const routeParts = routeParsedFull.split('/'); // ['shop', 'register', ':name', ':age']\n    const uriParts = uriParsedPath.split('/'); // ['shop', 'register', 'john', 23]\n\n    const params = {};\n\n    routeParts.forEach((routePart, index) => {\n      if (/\\:/.test(routePart)) {\n        const property = routePart.replace(/^\\:/, ''); // remove :\n\n        let value = uriParts[index];\n        value = this._typeConvertor(value); // t y p e   c o n v e r s i o n\n\n        params[property] = value;\n      }\n    });\n\n    return params;\n  }\n\n\n\n\n\n}\n\n\n\n\n\nmodule.exports = Router;\n\n},{}],4:[function(require,module,exports){\nclass Helper {\n\n  /**\n   * Get message size in bytes.\n   * For example: A -> 1 ,  -> 2 , ABC -> 3\n   * @param {string} msg - message sent to server\n   * @returns {number}\n   */\n  getMessageSize(msg) {\n    const bytes = new Blob([msg]).size;\n    return +bytes;\n  }\n\n\n  /**\n   * Pause the code execution\n   * @param {number} ms - miliseconds\n   * @returns {void}\n   */\n  async sleep(ms) {\n    await new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n\n  /**\n   * Create unique id. It's combination of wsOpts and random number 'r'\n   * in format: YYMMDDHHmmssSSSrrr ---> YY year, MM month, DD day, HH hour, mm min, ss sec, SSS ms, rrr 3 random digits\n   * 18 digits in total, for example: 210129163129492100\n   * @returns {number}\n   */\n  generateID() {\n    const rnd = Math.random() * 1000;\n    const rrr = Math.floor(rnd);\n\n    const timestamp = new Date();\n    const tsp = timestamp.toISOString()\n      .replace(/^20/, '')\n      .replace(/\\-/g, '')\n      .replace(/\\:/g, '')\n      .replace('T', '')\n      .replace('Z', '')\n      .replace('.', '');\n\n    const id = +(tsp + rrr);\n    return id;\n  }\n\n\n\n}\n\nconst helper = new Helper();\nmodule.exports = helper;\n\n},{}],5:[function(require,module,exports){\n/**\n * Subprotocol name: jsonRWS\n * HTTP header: \"Sec-WebSocket-Protocol\": \"jsonRWS\"\n *\n * Subprotocol description:\n *  This subprotocol is created for communication between websocket server and client.\n *\n * Subprotocol definitons:\n *  a) Client have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  b) Server have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  c) The message is converted from string to object.\n */\n\n\nclass JsonRWS {\n\n  /*********** INCOMING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for incoming messages. Filter and map incoming messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}.\n   * 2. Convert the message from string to object.\n   * @param {string} msgSTR -incoming message\n   * @returns {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}}\n   */\n  incoming(msgSTR) {\n    let tf = false;\n    let msg;\n    try {\n      msg = JSON.parse(msgSTR);\n      const msgObjProperties = Object.keys(msg);\n      tf = this._testFields(msgObjProperties);\n    } catch (err) {\n      tf = false;\n    }\n\n    if (tf) { return msg; }\n    else { throw new Error(`Incoming message \"${msgSTR}\" doesn\\'t have valid \"jsonRWS\" subprotocol format.`); }\n  }\n\n\n\n  /*********** OUTGOING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for outgoing messages. Filter and map outgoing messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload:any}.\n   * 2. Convert the message from object to string.\n   * @param {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}} msg - outgoing message\n   * @returns {string}\n   */\n  outgoing(msg) {\n    const msgObjProperties = Object.keys(msg);\n    const tf = this._testFields(msgObjProperties);\n\n    if (tf) {\n      const msgSTR = JSON.stringify(msg);\n      return msgSTR;\n    } else {\n      throw new Error(`Outgoing message ${JSON.stringify(msg)} doesn\\'t have valid \"jsonRWS\" subprotocol format.`);\n    }\n  }\n\n\n  /**\n   * Helper to test msg properties.\n   * @param {string[]} msgObjProperties - propewrties of the \"msg\" object\n   */\n  _testFields(msgObjProperties) {\n    const allowedFields = ['id', 'from', 'to', 'cmd', 'payload'];\n    const requiredFields = ['id', 'from', 'to', 'cmd'];\n    let tf = true;\n\n    // check if every of the msg properties are in allowed fields\n    for (const prop of msgObjProperties) {\n      if (allowedFields.indexOf(prop) === -1) { tf = false; break; }\n    }\n\n    // check if every of required fields is present\n    for (const requiredField of requiredFields) {\n      if(msgObjProperties.indexOf(requiredField) === -1) { tf = false; break; }\n    }\n\n    return tf;\n  }\n\n\n\n\n}\n\n\nmodule.exports = new JsonRWS();\n\n},{}]},{},[2]);\n"],"file":"client13jsonRWS-min.js"}