{"version":3,"sources":["client13jsonRWS.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","jsonRWS","helper","window","regoch","Client13jsonRWS","[object Object]","wcOpts","this","wsocket","socketID","attempt","wsURL","subproto","subprotocol","WebSocket","onEvents","close","attempts","recconectAttempts","delay","recconectDelay","console","log","sleep","connect","clientRequest","socket","unref","onopen","async","conn","infoSocketId","onclose","reset","reconnect","onerror","errorEvent","cb","onmessage","event","msg","data","debugger","msgObj","incoming","cmd","to","carryOut","undefined","Promise","resolve","reject","onMessage","timeout","answer","question","payload","id","generateID","from","outgoing","readyState","send","roomName","nickname","uri","body","textParts","text","join","debug","./lib/helper","./lib/subprotocol/jsonRWS","2","Blob","size","ms","setTimeout","rnd","Math","random","rrr","floor","Date","toISOString","replace","3","msgSTR","tf","JSON","parse","msgObjProperties","Object","keys","_testFields","err","stringify","allowedFields","requiredFields","prop","indexOf","requiredField"],"mappings":"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","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n * Websocket Client for Browser\n * - websocket version: 13\n * - subprotocol: jsonRWS\n */\nconst jsonRWS = require('./lib/subprotocol/jsonRWS');\nconst helper = require('./lib/helper');\n\n\nclass Client13jsonRWS {\n\n  /**\n   * @param {{wsURL:string, timeout:number, recconectAttempts:number, reconnectDelay:number, subprotocol:boolean, debug:boolean}} wcOpts - websocket client options\n   */\n  constructor(wcOpts) {\n    this.wcOpts = wcOpts; // websocket client options\n    this.wsocket; // Websocket instance https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n    this.socketID; // socket ID number, for example: 210214082949459100\n    this.attempt = 1; // reconnect attempt counter\n  }\n\n\n  /************* CLIENT CONNECTOR ************/\n  /**\n   * Connect to the websocket server.\n   * @returns {void}\n   */\n  connect() {\n    const wsURL = this.wcOpts.wsURL; // websocket URL: ws://localhost:3211/something?authkey=TRTmrt\n    const subproto = this.wcOpts.subprotocol ? ['jsonRWS'] : [];\n    this.wsocket = new WebSocket(wsURL, subproto);\n    this.onEvents();\n  }\n\n\n  /**\n   * Disconnect from the websocket server.\n   * @returns {void}\n   */\n  disconnect() {\n    this.wsocket.close();\n  }\n\n\n  /**\n   * Try to reconnect the client when the socket is closed.\n   * This method is fired on every 'close' socket's event.\n   */\n  async reconnect() {\n    const attempts = this.wcOpts.recconectAttempts;\n    const delay = this.wcOpts.recconectDelay;\n    console.log(this.attempt, attempts, delay);\n\n    if (this.attempt <= attempts) {\n      await helper.sleep(delay);\n      this.connect();\n      console.log(`Reconnect attempt #${this.attempt} of ${attempts} in ${delay}ms`);\n      this.attempt++;\n    }\n  }\n\n\n  /**\n   * Reset the properties.\n   */\n  reset() {\n    delete this.clientRequest;\n    if (!!this.socket) { this.socket.unref(); }\n    delete this.socket;\n  }\n\n\n  /**\n   * Event listeners.\n   * @returns {void}\n   */\n  onEvents() {\n    this.wsocket.onopen = async (conn) => {\n      this.socketID = await this.infoSocketId();\n      console.log('WS Connection opened');\n    };\n\n    this.wsocket.onclose = () => {\n      console.log('WS Connection closed');\n      this.reset();\n      this.reconnect();\n    };\n\n    this.wsocket.onerror = (errorEvent) => {\n      // console.error(errorEvent);\n    };\n  }\n\n\n\n\n  /************* RECEIVER ************/\n  /**\n   * Receive the message event and push it to msgStream.\n   * @param {Function} - callback function\n   * @returns {void}\n   */\n  onMessage(cb) {\n    this.wsocket.onmessage = (event) => {\n      const msg = event.data;\n      this.debugger('Received: ', msg);\n      const msgObj = jsonRWS.incoming(msg); // test against subprotocol rules and convert string to object\n      cb(msgObj);\n    };\n  }\n\n\n\n  /************* QUESTIONS ************/\n  /*** Send a question to the websocket server and wait for the answer. */\n  /**\n   * Send question and expect the answer.\n   * @param {string} cmd - command\n   * @returns {Promise<object>}\n   */\n  question(cmd) {\n    // send the question\n    const payload = undefined;\n    const to = this.socketID;\n    this.carryOut(to, cmd, payload);\n\n    // receive the answer\n    return new Promise(async (resolve, reject) => {\n      this.onMessage(async (msgObj) => {\n        if (msgObj.cmd === cmd) { resolve(msgObj); }\n      });\n      await helper.sleep(this.wcOpts.timeout);\n      reject(new Error(`No answer for the question: ${cmd}`));\n    });\n  }\n\n  /**\n   * Send question about my socket ID.\n   * @returns {Promise<number>}\n   */\n  async infoSocketId() {\n    const answer = await this.question('info/socket/id');\n    this.socketID = +answer.payload;\n    return this.socketID;\n  }\n\n  /**\n   * Send question about all socket IDs connected to the server.\n   * @returns {Promise<number[]>}\n   */\n  async infoSocketList() {\n    const answer = await this.question('info/socket/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms in the server.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomList() {\n    const answer = await this.question('info/room/list');\n    return answer.payload;\n  }\n\n  /**\n   * Send question about all rooms where the client was entered.\n   * @returns {Promise<{name:string, socketIds:number[]}[]>}\n   */\n  async infoRoomListmy() {\n    const answer = await this.question(`info/room/listmy`);\n    return answer.payload;\n  }\n\n\n\n\n\n\n  /************* SEND MESSAGE TO OTHER CLIENTS ************/\n  /**\n   * Send message to the websocket server if the connection is not closed (https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState).\n   * @param {number} to - final destination: 210201164339351900\n   * @param {string} cmd - command\n   * @param {any} payload - message payload\n   * @returns {void}\n   */\n  carryOut(to, cmd, payload) {\n    const id = helper.generateID(); // the message ID\n    const from = +this.socketID; // the sender ID\n    if (!to) { to = 0; } // server ID is 0\n    const msgObj = {id, from, to, cmd, payload};\n    const msg = jsonRWS.outgoing(msgObj);\n\n    // the message must be defined and client must be connected to the server\n    if (!!msg && !!this.wsocket && this.wsocket.readyState === 1) {\n      this.wsocket.send(msg);\n    } else {\n      throw new Error('The message is not defined or the client is disconnected.');\n    }\n  }\n\n\n  /**\n   * Send message (payload) to one client.\n   * @param {number} to - 210201164339351900\n   * @param {any} msg - message sent to the client\n   * @returns {void}\n   */\n  sendOne(to, msg) {\n    const cmd = 'socket/sendone';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to one or more clients.\n   * @param {number[]} to - [210205081923171300, 210205082042463230]\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  send(to, msg) {\n    const cmd = 'socket/send';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send message (payload) to all clients except the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  broadcast(msg) {\n    const cmd = 'socket/broadcast';\n    const payload = msg;\n    this.carryOut(cmd, payload);\n  }\n\n  /**\n   * Send message (payload) to all clients and the sender.\n   * @param {any} msg - message sent to the clients\n   * @returns {void}\n   */\n  sendAll(msg) {\n    const cmd = 'socket/sendall';\n    const payload = msg;\n    this.carryOut(cmd, payload);\n  }\n\n\n\n  /************* ROOM ************/\n  /**\n   * Subscribe in the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  roomEnter(roomName) {\n    const to = 0;\n    const cmd = 'room/enter';\n    const payload = roomName;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from the room.\n   * @param {string} roomName\n   * @returns {void}\n   */\n  roomExit(roomName) {\n    const to = 0;\n    const cmd = 'room/exit';\n    const payload = roomName;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Unsubscribe from all rooms.\n   * @returns {void}\n   */\n  roomExitAll() {\n    const to = 0;\n    const cmd = 'room/exitall';\n    const payload = undefined;\n    this.carryOut(to, cmd, payload);\n  }\n\n  /**\n   * Send message to the room.\n   * @param {string} roomName\n   * @param {any} msg\n   * @returns {void}\n   */\n  roomSend(roomName, msg) {\n    const to = roomName;\n    const cmd = 'room/send';\n    const payload = msg;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n\n\n  /********* SEND MESSAGE (COMMAND) TO SERVER *********/\n  /**\n   * Setup a nick name.\n   * @param {string} nickname - nick name\n   * @returns {void}\n   */\n  setNick(nickname) {\n    const to = 0;\n    const cmd = 'socket/nick';\n    const payload = nickname;\n    this.carryOut(to, cmd, payload);\n  }\n\n\n  /**\n   * Send route command.\n   * @param {string} uri - route URI, for example /shop/product/55\n   * @param {any} body - body\n   * @returns {void}\n   */\n  route(uri, body) {\n    const to = 0;\n    const cmd = 'route';\n    const payload = {uri, body};\n    this.carryOut(to, cmd, payload);\n  }\n\n\n\n  /**\n   * Debugger. Use it as this.debug(var1, var2, var3)\n   * @returns {void}\n   */\n  debugger(...textParts) {\n    const text = textParts.join('');\n    if (this.wcOpts.debug) { console.log(text); }\n  }\n\n\n\n}\n\n\nwindow.regoch = { Client13jsonRWS };\n\n},{\"./lib/helper\":2,\"./lib/subprotocol/jsonRWS\":3}],2:[function(require,module,exports){\nclass Helper {\n\n  /**\n   * Get message size in bytes.\n   * For example: A -> 1 , Š -> 2 , ABC -> 3\n   * @param {string} msg - message sent to server\n   * @returns {number}\n   */\n  getMessageSize(msg) {\n    const bytes = new Blob([msg]).size;\n    return +bytes;\n  }\n\n\n  /**\n   * Pause the code execution\n   * @param {number} ms - miliseconds\n   * @returns {void}\n   */\n  async sleep(ms) {\n    await new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n\n  /**\n   * Create unique id. It's combination of wsOpts and random number 'r'\n   * in format: YYMMDDHHmmssSSSrrr ---> YY year, MM month, DD day, HH hour, mm min, ss sec, SSS ms, rrr 3 random digits\n   * 18 digits in total, for example: 210129163129492100\n   * @returns {number}\n   */\n  generateID() {\n    const rnd = Math.random() * 1000;\n    const rrr = Math.floor(rnd);\n\n    const timestamp = new Date();\n    const tsp = timestamp.toISOString()\n      .replace(/^20/, '')\n      .replace(/\\-/g, '')\n      .replace(/\\:/g, '')\n      .replace('T', '')\n      .replace('Z', '')\n      .replace('.', '');\n\n    const id = +(tsp + rrr);\n    return id;\n  }\n\n\n\n}\n\nconst helper = new Helper();\nmodule.exports = helper;\n\n},{}],3:[function(require,module,exports){\n/**\n * Subprotocol name: jsonRWS\n * HTTP header: \"Sec-WebSocket-Protocol\": \"jsonRWS\"\n *\n * Subprotocol description:\n *  This subprotocol is created for communication between websocket server and client.\n *\n * Subprotocol definitons:\n *  a) Client have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  b) Server have to send message in valid JSON format. Allowed fields: id, from, to, cmd, payload.\n *  c) The message is converted from string to object.\n */\n\n\nclass JsonRWS {\n\n  /*********** INCOMING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for incoming messages. Filter and map incoming messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}.\n   * 2. Convert the message from string to object.\n   * @param {string} msgSTR -incoming message\n   * @returns {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}}\n   */\n  incoming(msgSTR) {\n    let tf = false;\n    let msg;\n    try {\n      msg = JSON.parse(msgSTR);\n      const msgObjProperties = Object.keys(msg);\n      tf = this._testFields(msgObjProperties);\n    } catch (err) {\n      tf = false;\n    }\n\n    if (tf) { return msg; }\n    else { throw new Error(`Incoming message \"${msgSTR}\" doesn\\'t have valid \"jsonRWS\" subprotocol format.`); }\n  }\n\n\n\n  /*********** OUTGOING MESSAGES ***********/\n  /**\n   * Execute the jsonRWS subprotocol for outgoing messages. Filter and map outgoing messages.\n   * 1. Test if the message has valid \"jsonRWS\" format {id:number, from:number, to:number|number[]|string, cmd:string, payload:any}.\n   * 2. Convert the message from object to string.\n   * @param {{id:number, from:number, to:number|number[]|string, cmd:string, payload?:any}} msg - outgoing message\n   * @returns {string}\n   */\n  outgoing(msg) {\n    const msgObjProperties = Object.keys(msg);\n    const tf = this._testFields(msgObjProperties);\n\n    if (tf) {\n      const msgSTR = JSON.stringify(msg);\n      return msgSTR;\n    } else {\n      throw new Error(`Outgoing message ${JSON.stringify(msg)} doesn\\'t have valid \"jsonRWS\" subprotocol format.`);\n    }\n  }\n\n\n  /**\n   * Helper to test msg properties.\n   * @param {string[]} msgObjProperties - propewrties of the \"msg\" object\n   */\n  _testFields(msgObjProperties) {\n    const allowedFields = ['id', 'from', 'to', 'cmd', 'payload'];\n    const requiredFields = ['id', 'from', 'to', 'cmd'];\n    let tf = true;\n\n    // check if every of the msg properties are in allowed fields\n    for (const prop of msgObjProperties) {\n      if (allowedFields.indexOf(prop) === -1) { tf = false; break; }\n    }\n\n    // check if every of required fields is present\n    for (const requiredField of requiredFields) {\n      if(msgObjProperties.indexOf(requiredField) === -1) { tf = false; break; }\n    }\n\n    return tf;\n  }\n\n\n\n\n}\n\n\nmodule.exports = new JsonRWS();\n\n},{}]},{},[1]);\n"],"file":"client13jsonRWS-min.js"}